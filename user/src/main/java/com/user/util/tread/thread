
======================================
1、什么是进程？2、什么是线程？3、什么是多线程？

1：当我们启动一个应用程序的时候，就会开启一个进程。
->wins任务管理器查看
->linux:ps 查看 kill-9 杀
在进程中至少有一条线程，该线程就是为主线程。
进程就是我们所有线程集合

2：线程就是一条程序执行路径，在进程中开启一条线程执行我们的程序代码。
执行顺序从上往下的顺序，注意：多线程情况下，代码就不是从上往下执行。

3：也就是在同一个进程中开启了多条不同的执行路径，每条执行路径相互不影响，同时执行。
======================================
多线程有哪些好处？
   提高程序执行效率。->为什么能够提高效率？ 并行，异步。
======================================
多线程有哪些应用场景？
    1：异步的实现发送短信，快速提高程序的响应，提高用户体验感。
    2：异步的实现记录日志。（AOP+异步[MQ]）
    3：对我们后端接口中比较耗时时间的低吗都可以采用异步实现。
    4：都是一个思想，能提高http协议的响应。（http 长连接 同步请求）
======================================
后端开发为什么需要使用多线程？
    因为我们的http协议默认的情况采用同步的形式，整个过程都是基于请求与响应过程，
如果服务器端没有及时的响应给客户端的情况下，就会造成我们浏览器或者是客户端一直等待，
这样对我们用户体验是非常不友好。
======================================
单线程与多线程执行到底有哪些区别？
    单线程：代码执行顺序，从上往下执行。若中途某个环节throws Exception 程序会中断
    整个代码执行的效率偏低。
    多线程：采用多条不同的线程执行我们代码程序，每个线程之间互不影响。提高响应速度。
======================================
如何理解多线程CPU切换概念？（上下文切换）
    单核CPU:多线程并不是真正意义上的多线程(并行)，因为单核cpu在同一时刻最多只能运行一个线程，
        需线程间抢占，切换。（切换会浪费资源）
    多核CPU: 多个CPU，同一时间在不同的CPU上可以存在一个不相同的线程运行，来达到并行的场景。
    （CAS）优化：可重入锁->比较并交换。"无锁"
======================================
多线程真的是越多越好吗？
    如果在服务器上频繁的开启线程的情况下，会导致CPU的不断切换，会影响服务器的新能。
        （使用线程池，队列阻塞，会走策略）。
    如果项目比较小的情况可以采用多线程实现异步，如果项目比较大的情况建议使用MQ实现异步。
    注意：如果高并发的项目，采用MQ。
======================================
线程的创建方式？
    1：extends Thread 重写run 方法
    2：implements Runnable 接口
    3：可以带返回结果的线程 Callable 接口 call()
    返回的是Future对象 用的是wait 和notify机制
    submit 带返回 execute 无返回。
    new Thread(new FutureTask(Callable 实现类)).start();
    获取结果会等待。一般用于查询耗时得到方法
    4: 线程池（线程复用，线程管理）
    Spring 异步注解@Async
======================================
run()主要做什么？
    线程需要执行的具体业务逻辑。
如何开启线程？
    为什么不直接调用run()，而需要调用start()
    直接调用run()不会创建线程，会当成一般的方法执行。
    start()会创建线程，在去调用run()
======================================
使用异步注解：@Async spring异步注解。代理模式 会失效
======================================
用户线程与守护线程的区别？
    用户线程：当主线程停止后，用户线程不会随着主线程停止。
    守护线程：当主线程停止后，守护线程也会跟着停止
    用户线程使用场景：程序中的业务线程
    守护线程使用场景：GC 线程
    thread.setDaemon()true->用户线程;false->守护线程
======================================
如何优雅得的停止一个线程？
    .stop()强制停止当前正在执行的线程。不建议使用。
    stat()->run()执行完，结束当前线程。
    volatile 线程可见性。
    改变线程执行状态。让run()完整的执行完成。
======================================
多线程的五种状态？
    new Thread() 新建
    .start() 就绪
    .run() 运行状态
    .sleep() 阻塞状态 ->到运行， 先就绪再运行
    运行完成 死亡状态
    锁： 运行->阻塞->就绪->运行
======================================
什么是线程安全问题？
    当多个线程同时共享一个全局变量做写操作的时候，可能会受到其他线程的干扰，
        就会产生线程安全问题，导致数据脏读（事务中未提交的数据）。
    产生背景：同一时间做写的操作。
======================================
如何解决线程安全问题？
    核心思想：在同一时间，只能有一个线程执行。(把并行的线程变成串行执行)
    即：加锁，对程序的效率会有影响。
    解决线程安全的方式：
        lock锁 、synchronized、CAS无锁(可重入) 、乐观锁
    在多个线程中，同时执行一个方法的时候，必须要过去锁，
        只有获取到锁的情况下，才可以进入到该方法执行。
    Eg：如果A线程获取到锁的情况下，那么B线程就会一直阻塞等待。整个过程是一个悲观锁，
        必须要等待A线程执行完代码释放锁之后，B线程从新进入到获取锁的状态。
        多个线程如何获取锁，看运气。
    注意：synchronized 修饰 static 方法时 是锁整个类。
    synchronized 在什么情况下释放锁：
        run()运行完毕，throws Exception
======================================
synchronized 的使用方式
    代码块的形式：可以使用任意对象作为锁。如果在方法上加synchronized 默认为当前对象锁
        静态方法是当前类的class作为锁，非静态是this
    定义对象锁：
    注意：synchronized ReentrantLock
    使用ReentrantLock的注意点
    ReentrantLock 和 synchronized 不一样，需要手动释放锁，
    所以使用 ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样
======================================
重入锁
    锁的分类：重入锁、乐观锁、悲观锁、自旋锁、CAS锁、非公平锁、公平锁 ->大致
如果锁不具有可重入性，则可能会发生死锁。
    当前同一线程可以直接获取该锁，不需要再次释放获取。
======================================
多线程死锁的想象
    产生背景：在同步中嵌套同步，也就是锁嵌套使用。(嵌套需要用可重入锁)
    如何排查死锁：
        分析拿到锁的对象是否是一致。
    排查工具：java jdk 自带多线程死锁排查工具。（JConsole）
======================================
synchronized 与Lock 的区别？
    synchronized 属于JAVA 内置关键字，内部封装
    Lock 是基于AQS 封装
    synchronized: 自动挡 自动释放
    Lock: 手动挡 可以完全人为控制 获取、释放 拓展性高
    Lock:可分 读、写
Lock（->ReentrantLock）: 重入锁、读写锁
    lock.lock()->获取锁 lock.unlock()->释放锁
    读、读：共享;
    写、写：互斥(同时只能执行一个线程);
    读、写：所有线程一起读，但不能一起写。
======================================
多线程之间的通信
    多个线程之间实现通讯 wait()等待 notify()唤醒



======================================
======================================
======================================
======================================
======================================
======================================

























































































































































































































































